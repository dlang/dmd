/*
PERMUTE_ARGS: -O -release
Test cases generated by AI.
*/

import core.stdc.stdio;

void arithmetic_expression_selftest()
{
    /* If a bit is set in `fail`, that test expression evaluated differently than expected. */
    uint fail = 0;
    uint t = 0;

    /* ---- precedence & associativity (integers) ---- */
    /* 1) * binds tighter than + */
    t = ((3 + 4 * 5) == (3 + (4 * 5)));
    fail |= cast(uint)(!t) << 0;

    /* 2) / binds tighter than - */
    t = ((20 - 12 / 3) == (20 - (12 / 3)));
    fail |= cast(uint)(!t) << 1;

    /* 3) left-associative subtraction: (a-b)-c */
    t = ((100 - 30 - 20) == ((100 - 30) - 20));
    fail |= cast(uint)(!t) << 2;

    /* 4) left-associative division: (a/b)/c */
    t = ((100 / 10 / 2) == ((100 / 10) / 2));
    fail |= cast(uint)(!t) << 3;

    /* 5) shift lower precedence than +: a << (b+c) is NOT (a<<b)+c */
    t = ((1u << 3 + 1) == (1u << (3 + 1)));
    fail |= cast(uint)(!t) << 4;

    /* 6) bitwise AND lower precedence than == : (x & y) == z */
    t = (((6 & 3) == 2) == (((6 & 3) == 2)));
    fail |= cast(uint)(!t) << 5;

    /* ---- integer truncation & modulo rules ---- */
    /* 7) integer division truncates toward zero in C99+ */
    t = (((-7) / 3) == (-2));
    fail |= cast(uint)(!t) << 6;

    /* 8) remainder sign follows the numerator in C99+ */
    t = (((-7) % 3) == (-1));
    fail |= cast(uint)(!t) << 7;

    /* ---- signed/unsigned usual arithmetic conversions ---- */
    /* 9) unsigned dominates in mixed ops */
    {
        uint u = 1u;
        int s = -2;
        /* s converted to unsigned: UINT_MAX-1, so u + s wraps to UINT_MAX */
        t = ((u + s) > u);
        /* In practice this is true because u+s becomes huge, but we only check
           relative ordering; if the implementation got conversions wrong, it may differ. */
        fail |= cast(uint)(!t) << 8;
    }

    /* ---- exact integer identities (no UB) ---- */
    /* 10) distributive property with small ints */
    t = ((7 * (9 + 11)) == (7 * 9 + 7 * 11));
    fail |= cast(uint)(!t) << 9;

    /* 11) (a^b)^b == a for uint */
    {
        uint a = 0xA5A5A5A5u, b = 0x3C3C3C3Cu;
        t = (((a ^ b) ^ b) == a);
        fail |= cast(uint)(!t) << 10;
    }

    /* ---- floating evaluation / conversion tests ---- */
    /* 12) conversion changes the meaning: cast(int)(x+y) vs cast(int)x + cast(int)y */
    {
        double x = 1.6, y = 1.6;
        t = ((cast(int)(x + y)) != (cast(int)x + cast(int)y)); /* 3 != 2 */
        fail |= cast(uint)(!t) << 11;
    }

    /* 13) float vs double rounding differences (should differ on most IEEE-754 systems) */
    {
        float  xf = 16777217.0f;   /* 2^24 + 1 cannot be represented in float */
        double xd = 16777217.0;    /* representable exactly in double */
        t = ((cast(double)xf) != xd);
        fail |= cast(uint)(!t) << 12;
    }

    /* 14) (a+b)+c vs a+(b+c) can differ in floating-point */
    {
        double a = 1e16, b = -1e16, c = 1.0;
        double left  = (a + b) + c;   /* (1e16-1e16)+1 = 1 */
        double right = a + (b + c);   /* 1e16+(-1e16+1) may round to 0 */
        t = (left != right);
        fail |= cast(uint)(!t) << 13;
    }

    /* 15) multiplication/division reassociation differs for floats */
    {
        double a = 1e308, b = 1e-308, c = 1e-308;
        double left  = (a * b) * c;
        double right = a * (b * c);
        /* one side likely underflows differently; we just expect "not always equal" */
        t = (left != right);
        fail |= cast(uint)(!t) << 14;
    }

    if (fail)
	printf("fail: x%x\n", fail);
}

int main()
{
    arithmetic_expression_selftest();
    return 0;
}
