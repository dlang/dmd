module vcg_ast_arraylength;
import object;
void main()
{
	int[] arr = [1, 2, 3];
	_d_arraysetlengthT(arr, 100LU, true);
	arr = arr[0..0] , 0;
	int[] f = null;
	int[] a = null;
	a = a[0..0] , (f = f[0..0] , 0);
	const const(int) x = 0;
	a = a[0..0] , (f = f[0..0] , 0);
	struct S
	{
		int[] payload;
	}
	S s = 0;
	(ref int[] __arraylength11 = s.payload;) , _d_arraysetlengthT(__arraylength11, __arraylength11.length + 3LU, true);
	return 0;
}
mixin _d_cmain!();
{
	extern (C)
	{
		extern (C) int _d_run_main(int argc, char** argv, void* mainFunc);
		extern (C) int _Dmain(char[][] args);
		extern (C) int main(int argc, char** argv)
		{
			return _d_run_main(argc, argv, & _Dmain);
		}
		version (Solaris)
		{
			extern (C) int _main(int argc, char** argv)
			{
				return main(argc, argv);
			}
		}
	}
}
_d_arraysetlengthT!(int[], int)
{
	pure nothrow @trusted ulong _d_arraysetlengthT(ref return scope int[] arr, ulong newlength, bool isMutable)
	{
		alias U = int;
		if (newlength == 0LU)
		{
			arr = null;
			return 0LU;
		}
		ulong elemSize = 4LU;
		ulong oldSize = arr.length * elemSize;
		ulong newSize = 0LU;
		bool overflow = false;
		newSize = mulu(elemSize, newlength, overflow);
		if (overflow)
		{
			return 0LU;
		}
		void[] oldSlice = cast(int*)arr ? cast(void[])arr : null;
		if (cast(void*)oldSlice !is null && gc_expandArrayUsed(oldSlice, newSize, false))
		{
			int* p = cast(int*)cast(void*)oldSlice;
			int* newElements = p + cast(long)arr.length * 4L;
			if (isMutable)
			{
				memset(cast(void*)newElements, 0, newSize - oldSize);
			}
			else
			{
				{
					ulong __key5 = 0LU;
					ulong __limit6 = newlength - arr.length;
					for (; __key5 < __limit6; __key5 += 1LU)
					{
						ulong i = __key5;
						emplace(&newElements[i], 0);
					}
				}
			}
			arr = p[0..newlength];
			return arr.length;
		}
		void* allocatedData = malloc(newSize, 2u, null);
		if (allocatedData is null)
		{
			return 0LU;
		}
		int* p = cast(int*)allocatedData;
		if (cast(int*)arr !is null)
		{
			memcpy(cast(void*)p, cast(const(void*))cast(int*)arr, oldSize);
		}
		int* newElements = p + cast(long)arr.length * 4L;
		if (isMutable)
		{
			memset(cast(void*)newElements, 0, newSize - oldSize);
		}
		else
		{
			{
				ulong __key7 = 0LU;
				ulong __limit8 = newlength - arr.length;
				for (; __key7 < __limit8; __key7 += 1LU)
				{
					ulong i = __key7;
					emplace(&newElements[i], 0);
				}
			}
		}
		arr = p[0..newlength];
		return arr.length;
	}

}
Unqual!(int, int)
{
	alias Unqual = int;

}
mulu!()
{
	pure nothrow @nogc @safe ulong mulu(ulong x, ulong y, ref bool overflow)
	{
		immutable @nogc immutable(ulong) r = x * y;
		if ((x | y) >> 32 && x && (r / x != y))
			overflow = true;
		return r;
	}

}
emplace!(int, int)
{
	pure nothrow @nogc @safe int* emplace(int* chunk, int __param_1)
	{
		import core.internal.lifetime : emplaceRef;
		emplaceRef(*chunk, fwd());
		return chunk;
	}

}
forward!(__param_1)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_1);
	}

}
fwd!(__param_1)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_1);
	}

}
move!int
{
	pure nothrow @nogc @safe int move(ref return scope int source)
	{
		return moveImpl(source);
	}

}
moveImpl!int
{
	pure nothrow @nogc @safe int moveImpl(ref return scope int source)
	{
		if (false)
			moveEmplaceImpl(source, source);
		return trustedMoveImpl(source);
	}

}
moveEmplaceImpl!int
{
	pure nothrow @nogc @safe void moveEmplaceImpl(ref scope int target, ref return scope int source)
	{
		import core.internal.traits : hasElaborateAssign, isAssignable, hasElaborateMove, hasElaborateDestructor, hasElaborateCopyConstructor;
		target = source;
	}

}
trustedMoveImpl!int
{
	pure nothrow @nogc @trusted int trustedMoveImpl(ref return scope int source)
	{
		int result = void;
		moveEmplaceImpl(result, source);
		return result;
	}

}
emplaceRef!(int, int, int)
{
	pure nothrow @nogc @safe void emplaceRef(ref int chunk, int __param_1)
	{
		static struct S
		{
			int payload;
			this()(auto ref Args args)
			{
				static if (__traits(compiles, payload = forward!args
				{
				}
				))
				{
					payload = forward!args
					{
					}
					;
				}
				else
				{
					payload = T(forward!args
					{
					}
					);
				}
			}
		}
		if (__ctfe)
		{
			chunk = fwd();
		}
		else
		{
			S* p = delegate () pure nothrow @nogc @trusted => cast(S*)&chunk();
			emplaceInitializer(*p);
			(*p).__ctor(fwd());
		}
	}

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
forward!(__param_1)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_1);
	}

}
fwd!(__param_1)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_1);
	}

}
emplaceInitializer!(S)
{
	pure nothrow @nogc @trusted void emplaceInitializer(ref scope S chunk)
	{
		import core.internal.traits : hasElaborateAssign;
		import core.stdc.string : memset;
		memset(cast(void*)&chunk, 0, 4LU);
	}

}
__ctor!()
{
	pure nothrow @nogc @safe this(int __param_0)
	{
		this.payload = fwd();
		return this;
	}

}
forward!(__param_0)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_0);
	}

}
fwd!(__param_0)
{
	auto pure nothrow @nogc @property @safe int fwd()
	{
		return move(__param_0);
	}

}
RTInfo!(S)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([16LU, 2LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [16LU, 2LU];

}
__equals!(int, int)
{
	pure nothrow @nogc @trusted bool __equals(scope const(int[]) lhs, scope const(int[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(int)*)lhs, cast(const(int)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(int)*)lhs, cast(const(void*))cast(const(int)*)rhs, length * 4LU));
		}
	}

}
isEqual!(int, int)
{
	pure nothrow @nogc @system bool isEqual(scope const(int*) t1, scope const(int*) t2, ulong length)
	{
		{
			ulong __key9 = 0LU;
			ulong __limit10 = length;
			for (; __key9 < __limit10; __key9 += 1LU)
			{
				const const(ulong) i = __key9;
				if (t1[i] != t2[i])
					return false;
			}
		}
		return true;
	}

}
static __gshared TypeInfo_Const _D12TypeInfo_xAi6__initZ;
