module vcg_ast_arraylength;
import object;
void main()
{
	int[] arr = [1, 2, 3];
	_d_arraysetlengthT(arr, 100LU);
	arr = arr[0..0] , 0;
	int[] f = null;
	int[] a = null;
	a = a[0..0] , (f = f[0..0] , 0);
	const const(int) x = 0;
	a = a[0..0] , (f = f[0..0] , 0);
	struct S
	{
		int[] payload;
	}
	S s = 0;
	(ref int[] __arraylength14 = s.payload;) , _d_arraysetlengthT(__arraylength14, __arraylength14.length + 3LU);
	return 0;
}
mixin _d_cmain!();
{
	extern (C)
	{
		extern (C) int _d_run_main(int argc, char** argv, void* mainFunc);
		extern (C) int _Dmain(char[][] args);
		extern (C) int main(int argc, char** argv)
		{
			return _d_run_main(argc, argv, & _Dmain);
		}
		version (Solaris)
		{
			extern (C) int _main(int argc, char** argv)
			{
				return main(argc, argv);
			}
		}
	}
}
_d_arraysetlengthT!(int[], int)
{
	pure nothrow @trusted ulong _d_arraysetlengthT(ref int[] arr, ulong newlength)
	{
		import core.lifetime : emplace;
		import core.internal.array.utils : __arrayAlloc;
		import object : TypeInfo;
		import core.stdc.string : memset;
		import core.stdc.string : memcpy;
		import core.internal.traits : Unqual;
		if (newlength == 0LU)
		{
			arr = null;
			return 0LU;
		}
		if (newlength <= arr.length)
		{
			arr = arr[0..newlength];
			return arr.length;
		}
		ulong sizeelem = 4LU;
		ulong newsize = 0LU;
		bool overflow = false;
		static pure nothrow @nogc @safe ulong mulu(ulong a, ulong b, ref bool overflow)
		{
			ulong result = a * b;
			overflow = b != 0LU && (result / b != a);
			return result;
		}
		newsize = mulu(sizeelem, newlength, overflow);
		if (overflow)
		{
			return 0LU;
		}
		if (cast(int*)arr is null)
		{
			assert(arr.length == 0LU);
			void[] allocatedData = __arrayAlloc(sizeelem * newlength);
			if (allocatedData.length == 0LU)
			{
				return 0LU;
			}
			int* p = cast(int*)cast(void*)allocatedData;
			{
				ulong __key8 = 0LU;
				ulong __limit9 = newlength;
				for (; __key8 < __limit9; __key8 += 1LU)
				{
					ulong i = __key8;
					p[i] = 0;
				}
			}
			arr = (cast(int*)cast(void*)allocatedData)[0..newlength];
			return arr.length;
		}
		ulong size = arr.length * sizeelem;
		void* oldData = cast(void*)cast(int*)arr;
		void[] allocatedData = __arrayAlloc(sizeelem * newlength);
		if (allocatedData.length == 0LU)
		{
			return 0LU;
		}
		memcpy(cast(void*)allocatedData, oldData, size);
		int* p = cast(int*)cast(void*)allocatedData + cast(long)arr.length * 4L;
		{
			ulong __key10 = 0LU;
			ulong __limit11 = newlength - arr.length;
			for (; __key10 < __limit11; __key10 += 1LU)
			{
				ulong i = __key10;
				p[i] = 0;
			}
		}
		arr = (cast(int*)cast(void*)allocatedData)[0..newlength];
		return arr.length;
	}

}
__arrayAlloc!(int[])
{
	pure nothrow @trusted void[] __arrayAlloc(ulong arrSize)
	{
		import core.lifetime : TypeInfoSize;
		import core.internal.traits : hasIndirections;
		enum ulong typeInfoSize = 0LU;
		BlkAttr attr = BlkAttr.APPENDABLE;
		void* ptr = malloc(arrSize, attr, typeid(int[]));
		if (ptr)
			return ptr[0..arrSize];
		return null;
	}

}
TypeInfoSize!(int[])
{
	enum ulong TypeInfoSize = 0LU;

}
hasIndirections!(int[])
{
	enum bool hasIndirections = true;

}
isFunctionPointer!(int[])
{
	enum bool isFunctionPointer = false;

}
isPointer!(int[])
{
	enum bool isPointer = false;

}
isAggregateType!(int[])
{
	enum bool isAggregateType = false;

}
isDelegate!(int[])
{
	enum bool isDelegate = false;

}
isDynamicArray!(int[])
{
	enum bool isDynamicArray = true;

}
DynamicArrayTypeOf!(int[])
{
	alias DynamicArrayTypeOf = int[];

}
OriginalType!(int[])
{
	alias OriginalType = int[];

}
ModifyTypePreservingTQ!(Impl, int[])
{
	alias ModifyTypePreservingTQ = int[];

}
Modifier!(int[])
{
	alias Impl = int[];

}
Unqual!(int[], int[])
{
	alias Unqual = int[];

}
RTInfo!(S)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([16LU, 2LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [16LU, 2LU];

}
__equals!(int, int)
{
	pure nothrow @nogc @trusted bool __equals(scope const(int[]) lhs, scope const(int[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(int)*)lhs, cast(const(int)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(int)*)lhs, cast(const(void*))cast(const(int)*)rhs, length * 4LU));
		}
	}

}
isEqual!(int, int)
{
	pure nothrow @nogc @system bool isEqual(scope const(int*) t1, scope const(int*) t2, ulong length)
	{
		{
			ulong __key12 = 0LU;
			ulong __limit13 = length;
			for (; __key12 < __limit13; __key12 += 1LU)
			{
				const const(ulong) i = __key12;
				if (t1[i] != t2[i])
					return false;
			}
		}
		return true;
	}

}
static __gshared TypeInfo_Const _D12TypeInfo_xAi6__initZ;
