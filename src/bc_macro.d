module ddmd.ctfe.bc_macro;

import ddmd.ctfe.bc_common;

void Byte3Macro(BCGen)(BCGen* gen, BCValue _result, BCValue word, BCValue idx)
{
    with(gen) {
    Eq3(BCValue.init, idx, BCValue(Imm32(0)));
    auto cndJmp1 = beginCndJmp();
    auto tmp1 = genTemporary(BCType(BCTypeEnum.i32));//SP[12]
    And3(_result, word, BCValue(Imm32(255)));
    auto label3 = genLabel();
    endCndJmp(cndJmp1, label3);
    Eq3(BCValue.init, idx, BCValue(Imm32(1)));
    auto cndJmp2 = beginCndJmp();
    And3(tmp1, word, BCValue(Imm32(65280)));
    Rsh3(_result, tmp1, BCValue(Imm32(8)));
    auto label5 = genLabel();
    endCndJmp(cndJmp2, label5);
    Eq3(BCValue.init, idx, BCValue(Imm32(2)));
    auto cndJmp3 = beginCndJmp();
    And3(tmp1, word, BCValue(Imm32(16711680)));
    Rsh3(_result, tmp1, BCValue(Imm32(16)));
    auto label7 = genLabel();
    endCndJmp(cndJmp3, label7);
    Eq3(BCValue.init, idx, BCValue(Imm32(3)));
    auto cndJmp4 = beginCndJmp();
    And3(tmp1, word, BCValue(Imm32(4278190080)));
    Rsh3(_result, tmp1, BCValue(Imm32(24)));
    auto label9 = genLabel();
    endCndJmp(cndJmp4, label9);
    //Assert(Error);
    }
}


//TODO This macro currenly computes the ByteOffset and Index two times
//Wereas one time should suffice
// Delete the duplicated code!
// Also remove unnecessary jumps at the end
/**
----
bool strEq(string a, string b, bool result = false;)
{
    result = false;

    if (a.length == b.length)
    {
        result = true;
        int length = cast(int)a.length;
        while(length--)
        {
            if (a[length] != b[length])
            {
                result = false;
                break;
            }
        }
    }

    return result;
}
----
*/
void StringEq3Macro(BCGen)(BCGen* gen, BCValue _result, BCValue lhs, BCValue rhs)
{
    with (gen)
    {
        auto p1 = lhs.i32; //SP[4]
        auto p2 = rhs.i32; //SP[8]
        auto p3 = genTemporary(BCType(BCTypeEnum.i32)); //SP[12]
        auto p4 = (_result ? _result.i32 : genTemporary(BCType(BCTypeEnum.i32))); //SP[16]
        Set(p4, BCValue(Imm32(0)));
        auto tmp1 = genTemporary(BCType(BCTypeEnum.i32)); //SP[20]
        auto tmp2 = genTemporary(BCType(BCTypeEnum.i32)); //SP[24]
        Load32(tmp2, p1);
        auto tmp3 = genTemporary(BCType(BCTypeEnum.i32)); //SP[28]
        Load32(tmp3, p2);
        Eq3(tmp1, tmp2, tmp3);
        auto cndJmp1 = beginCndJmp(tmp1);
        auto label1 = genLabel();
        Set(p4, BCValue(Imm32(1)));
        Load32(p3, p1);
        auto label2 = genLabel();
        auto tmp4 = genTemporary(BCType(BCTypeEnum.i32)); //SP[32]
        Set(tmp4, p3);
        Sub3(p3, p3, BCValue(Imm32(1)));
        auto cndJmp2 = beginCndJmp(tmp4);
        auto label3 = genLabel();
        auto tmp5 = genTemporary(BCType(BCTypeEnum.i32)); //SP[36]
        auto tmp6 = genTemporary(BCType(BCTypeEnum.i32)); //SP[40]
        Add3(tmp6, p1, BCValue(Imm32(1)));
        auto tmp7 = genTemporary(BCType(BCTypeEnum.Char)); //SP[44]
        auto tmp8 = genTemporary(BCType(BCTypeEnum.i32)); //SP[48]
        auto tmp9 = genTemporary(BCType(BCTypeEnum.i32)); //SP[52]
        Mod3(tmp9, p3, BCValue(Imm32(4)));
        Div3(tmp8, p3, BCValue(Imm32(4)));
        Add3(tmp6, tmp6, tmp8);
        Load32(tmp7, tmp6);
        Byte3(tmp7, tmp7, tmp9);
        auto tmp10 = genTemporary(BCType(BCTypeEnum.i32)); //SP[56]
        Add3(tmp10, p2, BCValue(Imm32(1)));
        auto tmp11 = genTemporary(BCType(BCTypeEnum.Char)); //SP[60]
        auto tmp12 = genTemporary(BCType(BCTypeEnum.i32)); //SP[64]
        auto tmp13 = genTemporary(BCType(BCTypeEnum.i32)); //SP[68]
        Mod3(tmp13, p3, BCValue(Imm32(4)));
        Div3(tmp12, p3, BCValue(Imm32(4)));
        Add3(tmp10, tmp10, tmp12);
        Load32(tmp11, tmp10);
        Byte3(tmp11, tmp11, tmp13);
        Neq3(tmp5, tmp7, tmp11);
        auto cndJmp3 = beginCndJmp(tmp5);
        auto label4 = genLabel();
        Set(p4, BCValue(Imm32(0)));
        auto jmp1 = beginJmp();
        auto label5 = genLabel();
        endJmp(jmp1, label5);
        auto jmp2 = beginJmp();
        auto label6 = genLabel();
        //auto label6 = genLabel();
        endJmp(jmp2, label6);
        endCndJmp(cndJmp3, label6);
        auto label7 = genLabel();
        genJump(label2);
        auto label8 = genLabel();
        endCndJmp(cndJmp2, label8);
        auto label9 = genLabel();
        endCndJmp(cndJmp1, label9);
        if (!_result) Eq3(BCValue.init, p4, BCValue(Imm32(1)));
    }
}





/** Autogenerated from :
----
 uint neededArraySize(uint size)
 {
      return (size - 1) / 4 + 2 + ((size & 3) == 0);
 }
----
 */ 
void ArraySizeForStringLengthMacro(BCGen)(BCGen* gen, BCValue result, BCValue stringLength)
{
	auto tmp2 = genTemporary(BCType(BCTypeEnum.i32));//SP[12]
	auto tmp3 = genTemporary(BCType(BCTypeEnum.i32));//SP[16]
	auto tmp4 = genTemporary(BCType(BCTypeEnum.i32));//SP[20]
	Sub3(tmp4, stringLength, BCValue(Imm32(1)));
	Div3(tmp3, tmp4, BCValue(Imm32(4)));
	Add3(tmp2, tmp3, BCValue(Imm32(2)));
	auto tmp5 = genTemporary(BCType(BCTypeEnum.i32));//SP[24]
	auto tmp6 = genTemporary(BCType(BCTypeEnum.i32));//SP[28]
	And3(tmp6, stringLength, BCValue(Imm32(3)));
	Eq3(tmp5, tmp6, BCValue(Imm32(0)));
	Add3(result, tmp2, tmp5);
}
/** This Macro is hand translated from 
auto strcat(const uint[] a, const uint[] b)
{
	uint aLength = a[0];
	uint bLength = b[0];
	uint resultLength = a[0] + b[0];
	uint[] result;
	result.length = neededArraySize(resultLength);
	result[0] = resultLength;
	auto resultPosition = 1;
	auto aMinusOne = !(aLength & 3);
	foreach (p, ca; a[1..$ - aMinusOne])
	{
		result[resultPosition++] = ca;
	}

        immutable uint offset = aLength & 3;
        if (offset)
        {
                immutable OffsetTimesEight = offset * 8;
                immutable FourMinusOffsetTimesEight = (4 - offset) * 8;
                immutable uint FirstAnd = (1 << FourMinusOffsetTimesEight) - 1;
                immutable uint SecondAnd = (~FirstAnd) & uint.max;

                resultPosition--;
                foreach (p, cb; b[1..$])
                {
                        result[resultPosition++] |= (cb & FirstAnd) << OffsetTimesEight;
                        if (resultPosition == result.length)
                                break;
                        result[resultPosition] |= (cb & SecondAnd) >> FourMinusOffsetTimesEight;
                }
        }
	else
	{
	auto bMinusOne = !(bLength & 3);
		foreach (p, cb; b[1..$ - bMinusOne])
		{
			result[resultPosition++] = cb;
		}
	}
	return result;
}
 */
void StringCat3Macro(BCGen)(BCGen* gen, BCValue _result, BCValue lhs, BCValue rhs)
{
	auto aLength = genTemporary(i32Type);
	auto bLength = genTemporary(i32Type);
	Load32(aLength, lhs.i32);
	Load32(bLength, rhs.i32);

	auto resultLength = genTemporary(i32Type);
	Add3(resultLength, aLength, bLength);

	auto allocSize = genTemporary(i32Type);
	ArraySizeForStringLengthMacro(gen, allocSize, resultLength);
	Alloc(_result, allocSize);
	Store32(_result, resultLength);
	auto resultPosition = genTemporary(i32Type);
	Add3(resultPosition, resultPosition, bcFour);

	auto offset = genTemporary(i32Type);
	And3(offset, aLength, BCValue(Imm32(3)));

	auto offsetZero = genTemporary(i32Type);
	Eq3(offsetZero, offset, bcZero);

	auto aPosition = genTemporary(i32Type);
	Add3(aPosition, lhs.i32, bcFour);
	auto aEnd = genTemporary(i32Type);
	ArraySizeForStringLengthMacro(gen, aEnd, resultLength);
	Sub3(aEnd, aEnd, offsetZero);

	Ge3(BCValue.init, aPosition, aEnd);
	// Or do we have to switch the loop condition ?
	auto aCopyLoop = beginCndJmp();
	{
		auto aCopyElement = genTemporary(i32Type);
		Load32(aCopyElement, aPosition);
		Add3(aPosition, aPosition, bcFour);
		Store32(resultPosition, aCopyElement);
		Add3(resultPosition, resultPosition, bcFour);
	}
	endCndJmp(aCopyLoop, genLabel());

	auto withOffset = beginCndJmp(offsetZero);
	{

	}
}
